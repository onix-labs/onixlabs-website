@page "/Products/Kotlin/Validation"

<PageTitle>ONIXLabs | Kotlin Validation Library</PageTitle>

<Section Class="bg-kotlin-fade" Centered="true">
    <Headline>Validation Library for Kotlin</Headline>
    <Callout>Consistent, type-safe validation built for real-world data.</Callout>
    <div class="col-12 col-md-4 offset-md-4">
        <Image Class="img-fluid" Description="Kotlin Validation Library"
               Url="onixlabs/images/icons/kotlin/kotlin-validation-outline.svg"/>
    </div>
    <Paragraph Lead="true">
        A fluent, type-safe validation framework for Kotlin that enables clear, expressive checks across complex object graphs. It supports
        nested rules, functional error accumulation, and reusable validators with customizable messaging. Designed for minimal boilerplate
        and seamless domain integration, it makes enforcing business constraints straightforward and maintainable.
    </Paragraph>
    <ActionButtons>
        <ActionButton Class="btn-dark" Icon="fa-brands fa-github" Text="View GitHub Repository" OpenInNewTab="true"
                      Url="https://github.com/onix-labs/onixlabs-kotlin-validation"/>
        <ActionButton Class="btn-dark" Icon="fa-solid fa-box-open" Text="View Maven Packages" OpenInNewTab="true"
                      Url="https://github.com/orgs/onix-labs/packages?repo_name=onixlabs-kotlin-validation"/>
    </ActionButtons>
</Section>

<Section>
    <Headline Centered="true">APIs at a Glance</Headline>
    <Callout Centered="true">Discover the capabilities built to elevate your Kotlin applications</Callout>

    <Row>
        <Summary Title="Validator & Validation Builder">
            <Paragraph>
                The Validator class orchestrates object validation through a builder DSL. The ValidationBuilder exposes concise
                property, function, and allProperties entry points that bind validations to data points. Assertions can be
                applied to any callable—including functions with up to 9 parameters—enabling flexible, expressive validation rules.
            </Paragraph>
        </Summary>
        <Summary Title="Member Assertion Context">
            <Paragraph>
                Each member under validation operates in a scoped MemberAssertionContext, which provides DSL-style syntax for
                expressing constraints using validate(condition, message) or nesting validations using validateWith(...).
                This enables clear local reasoning for both leaf and nested properties in complex object graphs.
            </Paragraph>
        </Summary>
    </Row>

    <Row>
        <Summary Title="Tree-Structured Validation Results">
            <Paragraph>
                Validation results are composed into a graph of ValidationResult and MemberResult nodes. These support deep
                inspection of validation failures across nested models, with automatic tracking of callables, types, and locations
                in the graph. Each assertion captures its exact position and semantics, ideal for debugging or UI feedback.
            </Paragraph>
        </Summary>
        <Summary Title="Assertion Semantics & Types">
            <Paragraph>
                Assertions are represented by MemberAssertion, which includes a failure message, type (relative or absolute),
                and a ValidationCondition. This allows layering of contextualized error messaging while supporting flexible
                validation modes.
            </Paragraph>
        </Summary>
    </Row>

    <Row>
        <Summary Title="Validation Modes & Exception Handling">
            <Paragraph>
                The engine supports multiple modes: STOP_ON_ERROR halts validation at the first failure, while EMULATION
                collects all failures into a complete result set. Exceptions are thrown as ValidationException or
                ValidationGraphException, and include detailed paths to the failing assertion within the graph.
            </Paragraph>
        </Summary>
        <Summary Title="Collection & Map Validations">
            <Paragraph>
                The API includes specialized support for Iterable, Map, String, Boolean, and Comparable extensions.
                These offer idiomatic assertions like isNullOrEmpty(), isTrue(), hasSize(...), isGreaterThan(...),
                and more, enabling readable, type-safe validation logic across domain types.
            </Paragraph>
        </Summary>
    </Row>
</Section>

<Section Class="bg-kotlin text-white">
    <Headline Class="text-white" Centered="true">Other Products for Kotlin</Headline>

    <hr class="mt-5"/>

    <Product
        Title="Core Library"
        ImageUrl="onixlabs/images/icons/kotlin/kotlin-core-outline.svg"
        InfoUrl="/Products/Kotlin/Core"
        Hook="Not flashy, but fiercely practical. The kind of toolkit that's quietly dependable.">
        Offers a comprehensive set of Kotlin extensions and utilities designed to streamline common programming tasks. It enhances standard
        types like Byte, Int, Double, and String with fluent, expressive operations, while also extending collections and mathematical types
        for cleaner code. The library includes time-related helpers, lightweight reflection tools, and flexible type conversion APIs to
        reduce boilerplate and improve readability. Built with clarity and consistency in mind, it supports developers looking to write more
        idiomatic and maintainable Kotlin.
    </Product>

    <hr/>

    <Product
        Title="Projection Library"
        ImageUrl="onixlabs/images/icons/kotlin/kotlin-projection-outline.svg"
        InfoUrl="/Products/Kotlin/Projection"
        Hook="Deceptively simple on the outside. Pure Kotlin magic where it counts.">
        A lightweight, convention-based projection library for Kotlin that enables clean, boilerplate-free mapping between data classes. It
        auto-maps matching fields, supports custom overrides, and leverages Kotlin’s reflection for safe, type-aware transformations. Ideal
        for converting between domain, DTO, and persistence models, it helps maintain clear layer separation with minimal overhead. Built
        for clarity and efficiency, it simplifies a traditionally messy task.
    </Product>
</Section>